# -*- coding: utf-8 -*-
"""LSTMmodel

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lUtOGq0J6aiyQJrqzY_z_4l4TrAPEsRz

#**Long Short Term Memory model for stock price prediction**

This notebook contains a Long Short Term Memory model for stock price prediction of Tesla common stock (TSLA). The data is retrieved from Yahoo finance, and it holds its historical data. 

This model is based on a technical analysis of the stock, which is the evaluation of stocks by means of studying statistics generated by market activity, such as past prices and volumes in order to identify patterns and trends that may indicate the future behaviour of the stock.

# Importing necessary packages
"""

import pandas as pd
import math
import numpy as np
import datetime
import pandas_datareader as pdr
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout
import matplotlib.pyplot as plt

"""# Data source
Retrieve data from Yahoo Finance. For this model, we will use Tesla common stock (TSLA) historical data listed on NASDAQ Stock exchange.
"""

#Retrieve data
tsla = pdr.get_data_yahoo('TSLA', start=datetime.datetime(2010, 1, 1), end=datetime.datetime(2020, 1, 1))

"""In this model we will only use one feature for stock prediction: closing price.

Also, we will divide our data in 80% and 20% for the training and testing phase respectively.
"""

# dataframe with only close column
data = tsla.filter(['Close'])
dataset = data.values
len_training_data = math.ceil(len(dataset) * .8)

"""In order for the data to be processed by our LSTM network, it needs to be normalised. With MinMaxScaler, the values of our features will be transformed to values between 0 and 1."""

# Normalisation
scaler = MinMaxScaler(feature_range=(0, 1))
normalised_data = scaler.fit_transform(dataset)

"""# Sliding window approach
This model uses a sliding window approach in order to predict a value. In other words, a prediction is made based on a 'window' of previous data. This model will compare a 60 width and 20 width window which contains the closing price of 60 and 20 days before the prediction day respectively.
"""

def sliding_window_train(normalised_data, window_size):
  train_data = normalised_data[0:len_training_data, :]
  X_train, Y_train = [], []

  for i in range(window_size, len(train_data)):
      X_train.append(train_data[i - window_size:i, 0])
      Y_train.append((train_data[i, 0]))

  X_train, Y_train = np.array(X_train), np.array(Y_train)
  X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))

  return X_train, Y_train

def sliding_window_test(normalised_data, len_training_data, window_size):

  test_data = normalised_data[len_training_data - window_size:, :]

  x_test= []

  for i in range(window_size, len(test_data)):
    x_test.append(test_data[i-window_size:i,0])

  x_test= np.array(x_test)
  x_test = np.reshape(x_test,(x_test.shape[0],x_test.shape[1],1))
  return x_test

"""**Train Data**"""

X_train, Y_train = sliding_window_train(normalised_data, 60)
X_train20, Y_train20 = sliding_window_train(normalised_data, 20)

"""**Test data**"""

x_test = sliding_window_test(normalised_data, len_training_data, 60)
y_test = dataset[len_training_data:,:]

x_test20 = sliding_window_test(normalised_data, len_training_data, 20)

"""# *LSTM neural network*

Our prediction model will be based on a LSTM neural network of 3 hidden layers, two LSTM and one dense layer. In order to prevent overfitting, a *dropout* layer has also been added to the model.
"""

# Define model
def LSTM_model(X_train,Y_train, x_test):
  model = Sequential()
  model.add(LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], 1)))
  model.add(LSTM(50, return_sequences=False))
  model.add(Dropout(0.2))
  model.add(Dense(25))
  model.add(Dense(1))

  # train phase
  model.compile(optimizer='adam', loss='mean_squared_error')
  history = model.fit(X_train, Y_train, batch_size=1, epochs=1)

  # testing phase
  predictions = model.predict(x_test)
  predictions = scaler.inverse_transform(predictions)
 
  return predictions

"""**Testing results**"""

predictions60= LSTM_model(X_train,Y_train, x_test)
predictions20 = LSTM_model(X_train20, Y_train20, x_test20)

"""**Root mean standard error**

"""

rmse = np.sqrt(np.mean(((predictions60 - y_test)**2)))
 rmse

rmse20 = np.sqrt(np.mean(((predictions20 - y_test)**2)))
rmse20

"""# Visualisation of results"""

train = data[:len_training_data]
valid = data[len_training_data:]

valid['Predictions 60'] = predictions60
valid['Predictions 20'] = predictions20

plt.figure(figsize=(20,10))
plt.title('Tesla Common Stock', fontsize=20)
plt.xlabel('Date', fontsize=18)
plt.ylabel('Close Price $', fontsize=18)
plt.plot(train['Close'])
plt.plot(valid[['Close','Predictions 60', 'Predictions 20']])
plt.legend(['Train', 'Actual Values', 'Predictions 60', 'Predictions 20'], loc='lower right')
plt.show()

valid
